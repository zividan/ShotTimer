<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Idan's Shot Timer</title>
  <style>
    /* =========== GLOBAL RESET & BACKGROUND =========== */
    * {
      margin: 0; 
      padding: 0; 
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: sans-serif;
      background: linear-gradient(135deg, #020202, #1a1a1a);
      color: #fff;
      position: relative;
    }
    /* Pulsing glow effect behind everything */
    body::before {
      content: "";
      position: absolute;
      top: 50%; left: 50%;
      width: 500px; height: 500px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,0,255,0.3) 0%, transparent 70%);
      animation: pulseGlow 3s alternate infinite ease-in-out;
      z-index: 0;
    }
    @keyframes pulseGlow {
      from {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.4;
      }
      to {
        transform: translate(-50%, -50%) scale(1.3);
        opacity: 0.6;
      }
    }

    /* =========== FIXED HEADER =========== */
    .header {
      position: fixed;
      top: 0; left: 0; right: 0;
      z-index: 10;
      background: rgba(0,0,0,0.4);
      backdrop-filter: blur(6px);
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
      padding: 1rem;
    }
    .header-inner {
      max-width: 700px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }
    .header h1 {
      font-size: 2.2rem;
      font-weight: 800;
      text-shadow: 0 0 8px rgba(255,255,255,0.5);
    }
    .timer {
      font-size: 3rem;
      text-shadow: 0 0 10px rgba(255,255,255,0.6);
      transition: color 0.3s ease;
    }
    .timer.running {
      color: #ff77ff; /* fuchsia */
    }
    .timer.paused {
      color: #b580ff; /* purple */
    }

    /* =========== BUTTONS =========== */
    .buttons {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      border: none;
      border-radius: 9999px;
      padding: 0.7rem 1.2rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      color: #fff;
      transition: 0.3s ease;
    }
    button:hover:not(:disabled) {
      opacity: 0.85;
    }
    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .start {
      background: #00c851; /* green */
    }
    .pause {
      background: #ff4444; /* red */
    }
    .next {
      background: #33b5e5; /* blue */
    }
    .reset-times {
      background: #666;
    }
    .reset-all {
      background: #999;
    }
    .copy-btn {
      background: #9c27b0; /* purple */
    }

    /* =========== CURRENT SHOT TEXT BOX =========== */
    .current-text-box {
      position: fixed;
      top: 200px; /* keep it lower so it won't overlap the buttons */
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      max-width: 700px;
      z-index: 9;
      padding: 0.8rem 1rem;
      background: rgba(0,0,0,0.3);
      backdrop-filter: blur(5px);
      border-radius: 1rem;
      box-shadow: 0 0 8px rgba(0,0,0,0.4);
      text-align: center;
      overflow: hidden; /* for the rolling animation */
      height: 4rem;     /* enough space for two lines */
    }
    .current-text-inner {
      position: relative;
      transition: transform 0.6s ease;
      /* We'll shift it up to animate */
      height: 100%;
    }
    .text-line {
      font-weight: 500;
      width: 100%;
      display: block;
      line-height: 2rem;
      text-shadow: 0 0 6px rgba(255,255,255,0.3);
      transition: color 0.6s ease;
    }
    .current-line {
      color: #ffecff;
      font-size: 1.1rem;
    }
    .next-line {
      color: #888;
      font-size: 1rem;
    }
    /* During the roll animation, we'll shift upward by 2rem. */
    .roll {
      transform: translateY(-2rem);
    }
    /* After roll, the next line becomes bright */
    .roll-done .next-line {
      color: #ffecff;
    }

    /* =========== MAIN CONTENT =========== */
    .main-content {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      justify-content: center;
      padding-top: 280px; /* space for header + current text box */
      overflow: hidden;
    }
    .content-wrapper {
      width: 100%;
      max-width: 700px;
      margin: 0 auto;
      position: relative;
      padding: 0 1rem 1rem;
    }
    .shots-scrollable {
      margin-top: 1rem;
      max-height: calc(100vh - 300px);
      overflow-y: auto;
      padding-right: 0.5rem;
      scroll-behavior: smooth; /* for smoother auto-scrolling */
    }
    .shots-header {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 1rem;
    }
    .shots-header h2 {
      font-size: 1.6rem;
      font-weight: 700;
      margin-bottom: 1rem;
      text-shadow: 0 0 6px rgba(255,255,255,0.4);
    }
    .copy-buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .shots-list {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    .shot-item {
      background: rgba(255,255,255,0.15);
      border-radius: 8px;
      padding: 0.6rem 1rem;
      box-shadow: 0 0 4px rgba(0,0,0,0.3);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
    }
    .shot-text {
      font-size: 0.9rem;
      font-weight: 500;
      color: #ffcfff;
      opacity: 0.9;
    }
    .highlighted {
      outline: 2px solid #fff;
      box-shadow: 0 0 8px rgba(255,255,255,0.7);
    }

    .no-shots {
      text-align: center;
      color: #ccc;
      font-weight: 500;
      margin-bottom: 1rem;
    }

    /* Hidden fallback for copy/paste */
    #hiddenCopyArea {
      position: absolute;
      left: -9999px;
      top: -9999px;
      opacity: 0;
    }
  </style>
</head>
<body>
  <!-- Fixed header at top -->
  <div class="header">
    <div class="header-inner">
      <h1>Idan's Shot Timer</h1>
      <div id="timer" class="timer paused">00:00</div>

      <!-- Main Buttons -->
      <div class="buttons">
        <button id="startPauseBtn" class="start">Start</button>
        <button id="nextShotBtn" class="next" disabled>Next Shot</button>
        <button id="resetTimesBtn" class="reset-times">Reset Times</button>
        <button id="resetAllBtn" class="reset-all">Reset All</button>
      </div>
    </div>
  </div>

  <!-- Current shot text box -->
  <div class="current-text-box">
    <div id="currentTextInner" class="current-text-inner">
      <span id="shotLineCurrent" class="text-line current-line">(No current)</span>
      <span id="shotLineNext" class="text-line next-line">(No next)</span>
    </div>
  </div>

  <!-- Shots area -->
  <div class="main-content">
    <div class="content-wrapper">
      <div class="shots-scrollable" id="shotsScroll">
        <div class="shots-header">
          <h2>Shots</h2>
          <div class="copy-buttons">
            <!-- 1) Paste Text (renamed, placed first) -->
            <button id="pasteTextsBtn" class="copy-btn">Paste Text</button>
            <!-- then the copy buttons -->
            <button id="copyColumnBtn" class="copy-btn" disabled>Copy as Column</button>
            <button id="copyRowBtn" class="copy-btn" disabled>Copy as Row</button>
            <button id="copyListBtn" class="copy-btn" disabled>Copy as List</button>
          </div>
        </div>

        <ul id="shotsList" class="shots-list"></ul>
        <p id="noShotsMsg" class="no-shots" style="display: none;">No shots recorded yet.</p>
      </div>
    </div>
  </div>

  <!-- Hidden fallback for copy/paste -->
  <textarea id="hiddenCopyArea"></textarea>

  <script>
    /* ============ STATE ============ */
    let elapsedTime = 0;
    let isRunning = false;
    let startTime = null;
    let timerInterval = null;

    // shots[i] = { text: string, start: number|undefined, end: number|undefined }
    const shots = [];
    let currentShotIndex = -1; // which shot is highlighted

    // DOM references
    const timerEl = document.getElementById('timer');
    const startPauseBtn = document.getElementById('startPauseBtn');
    const nextShotBtn = document.getElementById('nextShotBtn');
    const resetTimesBtn = document.getElementById('resetTimesBtn');
    const resetAllBtn = document.getElementById('resetAllBtn');

    const shotsList = document.getElementById('shotsList');
    const shotsScroll = document.getElementById('shotsScroll');
    const noShotsMsg = document.getElementById('noShotsMsg');

    const pasteTextsBtn = document.getElementById('pasteTextsBtn');
    const copyColumnBtn = document.getElementById('copyColumnBtn');
    const copyRowBtn = document.getElementById('copyRowBtn');
    const copyListBtn = document.getElementById('copyListBtn');
    const hiddenCopyArea = document.getElementById('hiddenCopyArea');

    // Next shot text lines
    const currentTextInner = document.getElementById('currentTextInner');
    const shotLineCurrent = document.getElementById('shotLineCurrent');
    const shotLineNext = document.getElementById('shotLineNext');

    /* ====== HELPER: Format mm:ss ====== */
    function formatTime(ms) {
      const totalSeconds = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
    }

    function updateTimerDisplay() {
      timerEl.textContent = formatTime(elapsedTime);
      timerEl.className = 'timer ' + (isRunning ? 'running' : 'paused');
    }

    function tick() {
      if (startTime !== null) {
        elapsedTime = Date.now() - startTime;
        updateTimerDisplay();
      }
    }

    /* ===== START/PAUSE ===== */
    function startTimer() {
      if (!isRunning) {
        // Start or resume
        startTime = Date.now() - elapsedTime;
        isRunning = true;
        startPauseBtn.textContent = 'Pause';
        startPauseBtn.className = 'pause';
        nextShotBtn.disabled = false;
        // If we have shots but no highlight yet, highlight first shot
        if (shots.length > 0 && currentShotIndex < 0) {
          currentShotIndex = 0;
          if (shots[0].start === undefined) {
            shots[0].start = elapsedTime;
          }
        }
        timerInterval = setInterval(tick, 100);
      } else {
        // Pause
        isRunning = false;
        startPauseBtn.textContent = 'Start';
        startPauseBtn.className = 'start';
        nextShotBtn.disabled = true;
        clearInterval(timerInterval);
        timerInterval = null;
      }
      updateTimerDisplay();
      renderShots();
      updateShotTextLines(false); // refresh shot lines
    }

    /* ===== NEXT SHOT ===== */
    function nextShot() {
      if (currentShotIndex < 0 || currentShotIndex >= shots.length) {
        alert('No available shot to set. Please paste texts or add shots first.');
        return;
      }
      // Ensure current shot has a start
      if (shots[currentShotIndex].start === undefined) {
        shots[currentShotIndex].start = elapsedTime;
      }
      // Set the end
      shots[currentShotIndex].end = elapsedTime;

      // Move to next shot
      const nextIndex = currentShotIndex + 1;
      if (nextIndex >= shots.length) {
        // no more shots
        alert('No more shots to highlight – you’ve recorded them all!');
      } else {
        currentShotIndex = nextIndex;
        // if new shot has no start, set it
        if (shots[currentShotIndex].start === undefined) {
          shots[currentShotIndex].start = elapsedTime;
        }
      }
      renderShots();
      // Perform the rolling text animation
      updateShotTextLines(true);
    }

    /* ====== 2 RESET BUTTONS ====== */
    function resetTimes() {
      // stop timer
      if (timerInterval) clearInterval(timerInterval);
      elapsedTime = 0;
      isRunning = false;
      startTime = null;
      timerInterval = null;
      shots.forEach(s => {
        s.start = undefined;
        s.end = undefined;
      });
      currentShotIndex = -1;
      startPauseBtn.textContent = 'Start';
      startPauseBtn.className = 'start';
      nextShotBtn.disabled = true;
      updateTimerDisplay();
      renderShots();
      updateShotTextLines(false);
    }

    function resetAll() {
      if (timerInterval) clearInterval(timerInterval);
      elapsedTime = 0;
      isRunning = false;
      startTime = null;
      timerInterval = null;
      shots.length = 0;
      currentShotIndex = -1;
      startPauseBtn.textContent = 'Start';
      startPauseBtn.className = 'start';
      nextShotBtn.disabled = true;
      updateTimerDisplay();
      renderShots();
      updateShotTextLines(false);
    }

    /* ===== RENDER SHOTS ===== */
    function renderShots() {
      shotsList.innerHTML = '';
      if (shots.length === 0) {
        noShotsMsg.style.display = 'block';
        copyColumnBtn.disabled = true;
        copyRowBtn.disabled = true;
        copyListBtn.disabled = true;
        return;
      }
      noShotsMsg.style.display = 'none';
      copyColumnBtn.disabled = false;
      copyRowBtn.disabled = false;
      copyListBtn.disabled = false;

      shots.forEach((shot, i) => {
        const li = document.createElement('li');
        li.className = 'shot-item';
        if (i === currentShotIndex) {
          li.classList.add('highlighted');
        }
        let label = `Shot ${i+1}: `;
        if (shot.start !== undefined && shot.end !== undefined) {
          label += `${formatTime(shot.start)} - ${formatTime(shot.end)}`;
        } else if (shot.start === undefined && shot.end === undefined) {
          label += '(no time)';
        } else {
          // partially set
          const st = shot.start !== undefined ? formatTime(shot.start) : '??:??';
          const en = shot.end !== undefined ? formatTime(shot.end) : '??:??';
          label += `${st} - ${en}`;
        }

        const shotLabelDiv = document.createElement('div');
        shotLabelDiv.textContent = label;

        const textSpan = document.createElement('span');
        textSpan.className = 'shot-text';
        textSpan.textContent = shot.text ? shot.text : '(No text)';

        li.appendChild(shotLabelDiv);
        li.appendChild(textSpan);
        shotsList.appendChild(li);
      });

      // Auto-scroll so the highlighted shot has ~3 shots below if possible
      if (currentShotIndex >= 0 && currentShotIndex < shots.length) {
        const item = shotsList.children[currentShotIndex];
        if (item) {
          // Position so that item is near top, leaving space for ~3 items
          const itemOffset = item.offsetTop;
          const itemHeight = item.offsetHeight;
          const containerHeight = shotsScroll.clientHeight;
          // We want the shot to appear ~ 1/4 from top
          const desiredTop = itemOffset - (containerHeight * 0.25);
          shotsScroll.scrollTo({
            top: desiredTop,
            behavior: 'smooth'
          });
        }
      }
    }

    /* ===== CURRENT & NEXT SHOT TEXT LINES (ROLL ANIMATION) ===== */
    function updateShotTextLines(doRoll) {
      // current shot text = shots[currentShotIndex]?.text 
      // next shot text = shots[currentShotIndex+1]?.text
      if (shots.length === 0) {
        shotLineCurrent.textContent = '(No current)';
        shotLineNext.textContent = '(No next)';
        return;
      }
      let idxCur = currentShotIndex < 0 ? 0 : currentShotIndex;
      if (idxCur >= shots.length) idxCur = shots.length - 1;
      const idxNext = idxCur + 1;

      const txtCur = shots[idxCur].text || '(No text)';
      const txtNext = (idxNext < shots.length) ? (shots[idxNext].text || '(No text)') : '(No next)';

      // Prepare the lines
      shotLineCurrent.textContent = txtCur;
      shotLineNext.textContent = txtNext;

      // If doRoll, we do the transition
      if (doRoll) {
        // Add class 'roll' to shift them up
        currentTextInner.classList.add('roll');
        // After the animation, we remove 'roll' but add 'roll-done' to finalize color
        setTimeout(() => {
          currentTextInner.classList.remove('roll');
          currentTextInner.classList.add('roll-done');
          // next animation frame to remove roll-done so next time we can do it again
          requestAnimationFrame(() => {
            currentTextInner.classList.remove('roll-done');
          });
        }, 600);
      } else {
        // no animation
        currentTextInner.classList.remove('roll');
      }
    }

    /* ===== COPY FUNCTIONS ===== */
    async function copyText(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        try {
          await navigator.clipboard.writeText(text);
          return true;
        } catch (e) {
          console.warn('Clipboard API failed:', e);
        }
      }
      hiddenCopyArea.value = text;
      hiddenCopyArea.select();
      hiddenCopyArea.setSelectionRange(0, text.length);
      return document.execCommand('copy');
    }

    function copyAsColumn() {
      const lines = shots.map(s => {
        if (s.start !== undefined && s.end !== undefined) {
          return `${formatTime(s.start)} - ${formatTime(s.end)}`;
        } else {
          return '(no time)';
        }
      });
      const text = lines.join('\n');
      copyText(text).then(ok => {
        alert(ok ? 'Copied as column!' : 'Copy failed.');
      });
    }
    function copyAsRow() {
      const lines = shots.map(s => {
        if (s.start !== undefined && s.end !== undefined) {
          return `${formatTime(s.start)} - ${formatTime(s.end)}`;
        } else {
          return '(no time)';
        }
      });
      const text = lines.join('\t');
      copyText(text).then(ok => {
        alert(ok ? 'Copied as row!' : 'Copy failed.');
      });
    }
    function copyAsList() {
      const lines = shots.map((s,i) => {
        const st = (s.start!==undefined)? formatTime(s.start) : '(no)';
        const en = (s.end!==undefined)? formatTime(s.end) : '(no)';
        return `Shot ${i+1}: ${st} - ${en}`;
      });
      const text = lines.join('\n');
      copyText(text).then(ok => {
        alert(ok ? 'Copied as list!' : 'Copy failed.');
      });
    }

    /* ===== PASTE TEXTS ===== */
    async function pasteTexts() {
      try {
        const str = await navigator.clipboard.readText();
        if (!str) {
          alert('Clipboard is empty or blocked.');
          return;
        }
        let lines = str.split('\n').map(l => l.trim()).filter(l => l !== '');
        let texts;
        if (lines.length > 1) {
          // multiple lines => column
          texts = lines;
        } else {
          // single line => row (tab separated)
          const singleLine = lines.length === 1 ? lines[0] : '';
          const items = singleLine.split('\t').map(i => i.trim()).filter(i => i !== '');
          texts = items.length ? items : [];
        }
        if (!texts.length) {
          alert('Could not parse any lines from clipboard');
          return;
        }
        if (shots.length < texts.length) {
          const needed = texts.length - shots.length;
          for (let i=0; i<needed; i++)
shots.push({ text: '', start: undefined, end: undefined });
          }
        }
        // Fill the first N
        const fillCount = Math.min(shots.length, texts.length);
        for (let i=0; i<fillCount; i++){
          shots[i].text = texts[i];
        }
        renderShots();
        updateShotTextLines(false);
        alert(`Pasted ${texts.length} text items. Created or updated ${fillCount} shots.`);
      } catch(e) {
        console.error('Failed to read from clipboard', e);
        alert('Failed to read from clipboard: '+e);
      }
    }

    /* ===== EVENT HANDLERS ===== */
    startPauseBtn.addEventListener('click', startTimer);
    nextShotBtn.addEventListener('click', nextShot);

    resetTimesBtn.addEventListener('click', resetTimes);
    resetAllBtn.addEventListener('click', resetAll);

    pasteTextsBtn.addEventListener('click', pasteTexts);
    copyColumnBtn.addEventListener('click', copyAsColumn);
    copyRowBtn.addEventListener('click', copyAsRow);
    copyListBtn.addEventListener('click', copyAsList);

    // init
    updateTimerDisplay();
    renderShots();
    shotLineCurrent.textContent = '(No current)';
    shotLineNext.textContent = '(No next)';
  </script>
</body>
</html>
